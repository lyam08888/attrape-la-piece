<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test du système de minage</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ccc;
            background: #87CEEB;
            display: block;
            margin: 20px auto;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        .info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .test-results {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test du système de minage et de gravité</h1>
        
        <div class="info">
            <h3>Instructions :</h3>
            <p>Cliquez sur les blocs pour les miner. Les blocs de sable (jaune) et de gravier (gris) tombent lorsqu'ils n'ont plus de support.</p>
            <p>Utilisez les boutons ci-dessous pour exécuter les tests automatiques.</p>
        </div>
        
        <div class="controls">
            <button onclick="runGravityTest()">Test de gravité</button>
            <button onclick="runBlockSupportTest()">Test de support des blocs</button>
            <button onclick="resetWorld()">Réinitialiser le monde</button>
        </div>
        
        <div id="testResults" class="test-results" style="display: none;">
            <h3>Résultats des tests :</h3>
            <pre id="testOutput"></pre>
        </div>
        
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        
        <div class="controls">
            <button onclick="addSandBlock()">Ajouter bloc de sable</button>
            <button onclick="addGravelBlock()">Ajouter bloc de gravier</button>
            <button onclick="addStoneBlock()">Ajouter bloc de pierre</button>
        </div>
    </div>

    <script>
        // Définir les constantes des blocs (simulées)
        const TILE = {
            AIR: 0,
            STONE: 1,
            SAND: 2,
            GRAVEL: 3
        };
        
        // Blocs qui ont de la gravité (tombent lorsqu'ils n'ont plus de support)
        const GRAVITY_BLOCKS = [
            TILE.SAND, TILE.GRAVEL
        ];
        
        // Fonction pour vérifier et faire tomber tous les blocs avec gravité qui n'ont plus de support
        function updateGravity(game) {
            // Limiter la fréquence de vérification de la gravité pour les performances
            if (!game.gravityTimer) game.gravityTimer = 0;
            game.gravityTimer++;
            
            // Vérifier la gravité seulement toutes les 5 frames
            if (game.gravityTimer < 5) return;
            game.gravityTimer = 0;
            
            const { tileSize } = game.config;
            const map = game.tileMap;
            
            // Parcourir la carte de haut en bas pour éviter les problèmes de décalage
            for (let y = map.length - 2; y >= 0; y--) {
                for (let x = 0; x < map[y].length; x++) {
                    const blockType = map[y][x];
                    
                    // Vérifier si le bloc a de la gravité
                    if (GRAVITY_BLOCKS.includes(blockType)) {
                        // Vérifier si le bloc a un support en dessous
                        const blockBelow = map[y + 1]?.[x];
                        
                        // Si le bloc en dessous est de l'air ou n'existe pas, le bloc tombe
                        if (!blockBelow || blockBelow === TILE.AIR) {
                            // Faire tomber le bloc
                            map[y][x] = TILE.AIR;
                            game.collectibles.push({
                                x: x * tileSize,
                                y: y * tileSize,
                                w: tileSize,
                                h: tileSize,
                                vy: 0.5, // Donner une vélocité initiale pour la chute
                                tileType: blockType
                            });
                        }
                    }
                }
            }
        }
        
        function checkBlockSupport(game, x, y) {
            // Vérifier si un bloc a besoin de support
            const block = game.tileMap[y]?.[x];
            if (!block) return;
            
            if (GRAVITY_BLOCKS.includes(block)) {
                // Vérifier si le bloc a un support en dessous
                const blockBelow = game.tileMap[y + 1]?.[x];
                
                // Si le bloc en dessous est de l'air ou n'existe pas, le bloc tombe
                if (!blockBelow || blockBelow === TILE.AIR) {
                    // Faire tomber le bloc
                    game.tileMap[y][x] = TILE.AIR;
                    game.collectibles.push({
                        x: x * game.config.tileSize,
                        y: y * game.config.tileSize,
                        w: game.config.tileSize,
                        h: game.config.tileSize,
                        vy: 0,
                        tileType: block
                    });
                }
            }
            
            // Vérifier également les blocs adjacents pour la gravité
            // Vérifier le bloc à gauche
            const blockLeft = game.tileMap[y]?.[x - 1];
            if (blockLeft && GRAVITY_BLOCKS.includes(blockLeft)) {
                const blockLeftBelow = game.tileMap[y + 1]?.[x - 1];
                if (!blockLeftBelow || blockLeftBelow === TILE.AIR) {
                    game.tileMap[y][x - 1] = TILE.AIR;
                    game.collectibles.push({
                        x: (x - 1) * game.config.tileSize,
                        y: y * game.config.tileSize,
                        w: game.config.tileSize,
                        h: game.config.tileSize,
                        vy: 0,
                        tileType: blockLeft
                    });
                }
            }
            
            // Vérifier le bloc à droite
            const blockRight = game.tileMap[y]?.[x + 1];
            if (blockRight && GRAVITY_BLOCKS.includes(blockRight)) {
                const blockRightBelow = game.tileMap[y + 1]?.[x + 1];
                if (!blockRightBelow || blockRightBelow === TILE.AIR) {
                    game.tileMap[y][x + 1] = TILE.AIR;
                    game.collectibles.push({
                        x: (x + 1) * game.config.tileSize,
                        y: y * game.config.tileSize,
                        w: game.config.tileSize,
                        h: game.config.tileSize,
                        vy: 0,
                        tileType: blockRight
                    });
                }
            }
            
            // Vérifier le bloc au-dessus
            const blockAbove = game.tileMap[y - 1]?.[x];
            if (blockAbove && GRAVITY_BLOCKS.includes(blockAbove)) {
                const blockAboveBelow = game.tileMap[y]?.[x];
                if (!blockAboveBelow || blockAboveBelow === TILE.AIR) {
                    game.tileMap[y - 1][x] = TILE.AIR;
                    game.collectibles.push({
                        x: x * game.config.tileSize,
                        y: (y - 1) * game.config.tileSize,
                        w: game.config.tileSize,
                        h: game.config.tileSize,
                        vy: 0,
                        tileType: blockAbove
                    });
                }
            }
        }
        
        // Configuration du jeu
        const config = {
            tileSize: 16,
            physics: {
                gravity: 0.35
            }
        };
        
        // Créer le canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Créer une carte de test
        let tileMap = [
            [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE],
            [TILE.SAND, TILE.AIR, TILE.AIR, TILE.SAND, TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE],
            [TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE],
            [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE]
        ];
        
        // Ajouter plus de lignes vides
        for (let i = 4; i < 30; i++) {
            tileMap.push(new Array(10).fill(TILE.AIR));
        }
        
        // Collectibles (blocs qui tombent)
        let collectibles = [];
        
        // Timer pour la gravité
        let gravityTimer = 0;
        
        // Créer l'objet game
        const game = {
            config: config,
            tileMap: tileMap,
            collectibles: collectibles,
            gravityTimer: gravityTimer
        };
        
        // Fonction pour dessiner un bloc
        function drawTile(x, y, tileType) {
            const screenX = x * config.tileSize;
            const screenY = y * config.tileSize;
            
            switch (tileType) {
                case TILE.STONE:
                    ctx.fillStyle = '#808080';
                    break;
                case TILE.SAND:
                    ctx.fillStyle = '#F4A460';
                    break;
                case TILE.GRAVEL:
                    ctx.fillStyle = '#A0A0A0';
                    break;
                case TILE.AIR:
                default:
                    return; // Ne pas dessiner l'air
            }
            
            ctx.fillRect(screenX, screenY, config.tileSize, config.tileSize);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(screenX, screenY, config.tileSize, config.tileSize);
        }
        
        // Fonction pour dessiner un collectible
        function drawCollectible(c) {
            const screenX = c.x;
            const screenY = c.y;
            
            switch (c.tileType) {
                case TILE.SAND:
                    ctx.fillStyle = '#F4A460';
                    break;
                case TILE.GRAVEL:
                    ctx.fillStyle = '#A0A0A0';
                    break;
                default:
                    ctx.fillStyle = '#808080';
            }
            
            ctx.fillRect(screenX, screenY, c.w, c.h);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(screenX, screenY, c.w, c.h);
        }
        
        // Fonction pour dessiner la carte
        function drawMap() {
            // Dessiner le fond
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner les blocs
            for (let y = 0; y < tileMap.length; y++) {
                for (let x = 0; x < tileMap[y].length; x++) {
                    drawTile(x, y, tileMap[y][x]);
                }
            }
            
            // Dessiner les collectibles
            collectibles.forEach(c => {
                drawCollectible(c);
            });
        }
        
        // Fonction pour mettre à jour la physique des collectibles
        function updateCollectibles() {
            for (let i = 0; i < collectibles.length; i++) {
                const c = collectibles[i];
                
                // Appliquer la gravité
                c.vy += config.physics.gravity;
                c.y += c.vy;
                
                // Vérifier la collision avec le sol
                const tileX = Math.floor(c.x / config.tileSize);
                const tileY = Math.floor((c.y + c.h) / config.tileSize);
                const groundTile = tileMap[tileY]?.[tileX];
                
                // Si le collectible touche un bloc solide, il s'arrête
                if (groundTile > TILE.AIR) {
                    c.y = tileY * config.tileSize - c.h;
                    c.vy = 0;
                }
            }
        }
        
        // Fonction pour miner un bloc
        function mineBlock(x, y) {
            const tileX = Math.floor(x / config.tileSize);
            const tileY = Math.floor(y / config.tileSize);
            
            if (tileMap[tileY] && tileMap[tileY][tileX] > TILE.AIR) {
                // Détruire le bloc
                tileMap[tileY][tileX] = TILE.AIR;
                
                // Vérifier les blocs adjacents pour la gravité
                checkBlockSupport(game, tileX, tileY);
            }
        }
        
        // Fonction pour ajouter un bloc de sable
        function addSandBlock() {
            // Trouver un emplacement vide en haut
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < tileMap[y].length; x++) {
                    if (tileMap[y][x] === TILE.AIR) {
                        tileMap[y][x] = TILE.SAND;
                        return;
                    }
                }
            }
        }
        
        // Fonction pour ajouter un bloc de gravier
        function addGravelBlock() {
            // Trouver un emplacement vide en haut
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < tileMap[y].length; x++) {
                    if (tileMap[y][x] === TILE.AIR) {
                        tileMap[y][x] = TILE.GRAVEL;
                        return;
                    }
                }
            }
        }
        
        // Fonction pour ajouter un bloc de pierre
        function addStoneBlock() {
            // Trouver un emplacement vide en haut
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < tileMap[y].length; x++) {
                    if (tileMap[y][x] === TILE.AIR) {
                        tileMap[y][x] = TILE.STONE;
                        return;
                    }
                }
            }
        }
        
        // Fonction pour réinitialiser le monde
        function resetWorld() {
            // Réinitialiser la carte
            tileMap = [
                [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE],
                [TILE.SAND, TILE.AIR, TILE.AIR, TILE.SAND, TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE],
                [TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE],
                [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE]
            ];
            
            // Ajouter plus de lignes vides
            for (let i = 4; i < 30; i++) {
                tileMap.push(new Array(10).fill(TILE.AIR));
            }
            
            // Réinitialiser les collectibles
            collectibles = [];
            
            // Réinitialiser le timer
            gravityTimer = 0;
            
            // Mettre à jour l'objet game
            game.tileMap = tileMap;
            game.collectibles = collectibles;
            game.gravityTimer = gravityTimer;
        }
        
        // Fonction de test pour vérifier la gravité des blocs
        function runGravityTest() {
            const output = document.getElementById('testOutput');
            const results = document.getElementById('testResults');
            results.style.display = 'block';
            
            output.textContent = "Test de la gravité des blocs...\n";
            
            // Créer une carte de test
            const testMap = [
                [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE],
                [TILE.SAND, TILE.AIR, TILE.AIR, TILE.SAND, TILE.STONE],
                [TILE.STONE, TILE.AIR, TILE.AIR, TILE.AIR, TILE.STONE],
                [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE]
            ];
            
            const testGame = {
                config: config,
                tileMap: testMap,
                collectibles: [],
                gravityTimer: 0
            };
            
            output.textContent += "État initial de la carte:\n";
            output.textContent += JSON.stringify(testMap, null, 2) + "\n";
            
            // Exécuter la mise à jour de la gravité
            updateGravity(testGame);
            
            output.textContent += "État après la gravité:\n";
            output.textContent += JSON.stringify(testMap, null, 2) + "\n";
            output.textContent += "Collectibles créés:\n";
            output.textContent += JSON.stringify(testGame.collectibles, null, 2) + "\n";
            
            // Vérifier que les blocs de sable ont été convertis en collectibles
            if (testGame.collectibles.length > 0) {
                output.textContent += "✅ Test réussi: Les blocs avec gravité tombent correctement\n";
            } else {
                output.textContent += "❌ Test échoué: Les blocs avec gravité n'ont pas été traités\n";
            }
        }
        
        // Fonction de test pour vérifier checkBlockSupport
        function runBlockSupportTest() {
            const output = document.getElementById('testOutput');
            const results = document.getElementById('testResults');
            results.style.display = 'block';
            
            output.textContent = "Test de checkBlockSupport...\n";
            
            // Créer une carte de test
            const testMap = [
                [TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR, TILE.AIR],
                [TILE.SAND, TILE.AIR, TILE.AIR, TILE.SAND, TILE.AIR],
                [TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE, TILE.STONE]
            ];
            
            const testGame = {
                config: config,
                tileMap: testMap,
                collectibles: []
            };
            
            output.textContent += "État initial de la carte:\n";
            output.textContent += JSON.stringify(testMap, null, 2) + "\n";
            output.textContent += "Collectibles initiaux:\n";
            output.textContent += JSON.stringify(testGame.collectibles, null, 2) + "\n";
            
            // Exécuter checkBlockSupport sur le bloc de sable en (0, 1)
            checkBlockSupport(testGame, 0, 1);
            
            output.textContent += "État après checkBlockSupport:\n";
            output.textContent += JSON.stringify(testMap, null, 2) + "\n";
            output.textContent += "Collectibles créés:\n";
            output.textContent += JSON.stringify(testGame.collectibles, null, 2) + "\n";
            
            // Vérifier que le bloc de sable a été converti en collectible
            if (testGame.collectibles.length > 0) {
                output.textContent += "✅ Test réussi: checkBlockSupport fonctionne correctement\n";
            } else {
                output.textContent += "❌ Test échoué: checkBlockSupport n'a pas fonctionné\n";
            }
        }
        
        // Gestion des clics sur le canvas
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            mineBlock(x, y);
        });
        
        // Boucle de jeu
        function gameLoop() {
            // Mettre à jour la physique des collectibles
            updateCollectibles();
            
            // Mettre à jour la gravité
            updateGravity(game);
            
            // Dessiner la carte
            drawMap();
            
            // Continuer la boucle
            requestAnimationFrame(gameLoop);
        }
        
        // Démarrer la boucle de jeu
        gameLoop();
        
        // Dessiner la carte initiale
        drawMap();
    </script>
</body>
</html>
