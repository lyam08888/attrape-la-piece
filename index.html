<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <!-- CORRECTION: Suppression de 'user-scalable=no' pour une meilleure accessibilité -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Pixel Adventure 2 - Corrigé</title>
    <link rel="icon" href="https://placehold.co/32x32/f9a825/000000?text=P">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root {
            --primary-color: #f9a825;
            --secondary-color: #a15c1e;
            --text-light: #F0F0F0;
            --border-color: #4A4A4A;
            --background-dark: #1A1A1A;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0d1117;
            color: var(--text-light);
        }
        body {
            font-family: 'Press Start 2P', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #gameWrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #gameCanvas {
            display: block;
            background: #000;
            /* CORRECTION: Ajout de la propriété pour Edge pour un rendu net */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(4px);
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 10;
        }
        .overlay.active {
            visibility: visible;
            opacity: 1;
        }
        .menu-box {
            background: #1e1e1e;
            border: 4px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .menu-box h2 {
            font-size: 1.5em;
            margin-bottom: 25px;
            color: var(--primary-color);
            text-shadow: 2px 2px 0px var(--secondary-color);
        }
        .menu-box button {
            font-family: inherit;
            font-size: 1em;
            padding: 12px 20px;
            cursor: pointer;
            background: linear-gradient(to bottom, #5a5a5a, #3a3a3a);
            border: 2px solid var(--border-color);
            border-bottom: 4px solid #2a2a2a;
            border-radius: 8px;
            color: var(--text-light);
            margin-top: 10px;
            width: 100%;
        }
        #hud {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        .hud-info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            color: white;
            font-size: 1em;
            text-shadow: 2px 2px #000;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.4);
            padding: 5px;
            border-radius: 8px;
        }
        .toolbar-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #888;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .toolbar-slot.selected {
            border-color: var(--primary-color);
            transform: scale(1.1);
        }
        .toolbar-slot img {
            width: 80%;
            height: 80%;
        }
        /* CORRECTION: Ajout de labels pour les options pour l'accessibilité */
        .option-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            text-align: left;
        }
        .option-group label {
            cursor: pointer;
        }
        .option-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="mainMenu" class="overlay active">
            <div class="menu-box">
                <h2>Super Pixel Adventure 2</h2>
                <p style="margin-bottom: 20px; font-size: 0.8em; line-height: 1.5;">Le code a été restructuré pour être fonctionnel.</p>
                <button id="startGame">Démarrer le Jeu</button>
            </div>
        </div>
        <div id="hud">
            <div class="hud-info">
                <span id="lives">Vies: 5</span>
            </div>
            <div id="toolbar"></div>
        </div>
        <div id="optionsMenu" class="overlay">
            <div class="menu-box">
                <h2>OPTIONS</h2>
                <div class="option-group">
                    <label for="renderDistanceSlider">Distance d'affichage</label>
                    <span id="renderDistanceValue">8 chunks</span>
                </div>
                <input type="range" id="renderDistanceSlider" min="4" max="16" value="8">
                
                <div class="option-group" style="margin-top: 20px;">
                    <label for="zoomSlider">Zoom</label>
                    <span id="zoomValue">x3</span>
                </div>
                <input type="range" id="zoomSlider" min="1" max="5" value="3" step="0.25">

                <div class="option-group" style="margin-top:20px;">
                    <label for="particlesCheckbox">Particules</label>
                    <input type="checkbox" id="particlesCheckbox">
                </div>
                <div class="option-group">
                    <label for="weatherCheckbox">Météo</label>
                    <input type="checkbox" id="weatherCheckbox">
                </div>
                <div class="option-group">
                    <label for="lightingCheckbox">Lumière dynamique</label>
                    <input type="checkbox" id="lightingCheckbox">
                </div>
                <div class="option-group">
                    <label for="mobileModeCheckbox">Mode Mobile</label>
                    <input type="checkbox" id="mobileModeCheckbox">
                </div>

                <div class="option-group" style="margin-top:20px;">
                    <label for="soundSlider">Volume</label>
                    <span id="volumeValue">80%</span>
                </div>
                <input type="range" id="soundSlider" min="0" max="1" step="0.1" value="0.8">
                
                <button data-action="closeOptions">RETOUR</button>
            </div>
        </div>
    </div>

    <script type="module">
        // ===================================================================================
        // FICHIER : seededRandom.js
        // RÔLE : Générateur de nombres pseudo-aléatoires basé sur une graine.
        // ===================================================================================
        const SeededRandom = {
            seed: 12345,
            setSeed(newSeed) { this.seed = newSeed; },
            random: function() {
                var x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
        };

        // ===================================================================================
        // FICHIER : perlin.js
        // RÔLE : Générateur de bruit de Perlin pour un terrain naturel.
        // ===================================================================================
        const Perlin = {
            rand_vect: function(){ let theta = SeededRandom.random()*2*Math.PI; return {x:Math.cos(theta), y:Math.sin(theta)}; },
            dot_prod_grid: function(x, y, vx, vy){
                let g_vect; let d_vect = {x:x-vx, y:y-vy};
                if (this.gradients[[vx,vy]]){ g_vect = this.gradients[[vx,vy]]; }
                else { g_vect = this.rand_vect(); this.gradients[[vx,vy]] = g_vect; }
                return d_vect.x*g_vect.x + d_vect.y*g_vect.y;
            },
            smootherstep: (x) => 6*x**5 - 15*x**4 + 10*x**3,
            interp: function(x, a, b){ return a + this.smootherstep(x)*(b-a); },
            seed: function(){ this.gradients = {}; this.memory = {}; },
            get: function(x, y) {
                if (this.memory.hasOwnProperty([x,y])) return this.memory[[x,y]];
                let xf = Math.floor(x); let yf = Math.floor(y);
                let tl = this.dot_prod_grid(x, y, xf,   yf); let tr = this.dot_prod_grid(x, y, xf+1, yf);
                let bl = this.dot_prod_grid(x, y, xf,   yf+1); let br = this.dot_prod_grid(x, y, xf+1, yf+1);
                let xt = this.interp(x-xf, tl, tr); let xb = this.interp(x-xf, bl, br);
                let v = this.interp(y-yf, xt, xb); this.memory[[x,y]] = v;
                return v;
            }
        };

        // ===================================================================================
        // FICHIER : world.js
        // RÔLE : Constantes des tuiles et génération du monde.
        // ===================================================================================
        const TILE = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, COAL: 6, IRON: 7,
            SAND: 15,
        };

        function generateLevel(game, config) {
            SeededRandom.setSeed(config.seed || 12345);
            Perlin.seed();
            
            const width = Math.floor(config.worldWidth / config.tileSize);
            const height = Math.floor(config.worldHeight / config.tileSize);

            game.tileMap = Array.from({ length: height }, () => Array(width).fill(TILE.AIR));
            game.decorations = []; game.enemies = []; game.pnjs = [];

            const surfaceLevel = Math.floor(height * 0.4);

            // Génération du terrain de base avec Perlin Noise
            for (let x = 0; x < width; x++) {
                const groundY = surfaceLevel + Math.floor(Perlin.get(x * 0.05, 0) * 10);
                for (let y = groundY; y < height; y++) {
                    if (y === groundY) {
                        game.tileMap[y][x] = TILE.GRASS;
                    } else if (y < groundY + 5) {
                        game.tileMap[y][x] = TILE.DIRT;
                    } else {
                        game.tileMap[y][x] = TILE.STONE;
                    }
                }
            }

            // Ajout des arbres
            for (let i = 0; i < (config.generation.treeCount || 20); i++) {
                const x = Math.floor(SeededRandom.random() * (width - 10)) + 5;
                for (let y = 10; y < height; y++) {
                    if (game.tileMap[y][x] === TILE.GRASS && game.tileMap[y - 1][x] === TILE.AIR) {
                        const treeHeight = 5 + Math.floor(SeededRandom.random() * 5);
                        for (let j = 0; j < treeHeight; j++) {
                            if (y - 1 - j > 0) game.tileMap[y - 1 - j][x] = TILE.WOOD;
                        }
                        const leafRadius = 3;
                        const leafCenterY = y - treeHeight;
                        for(let ly = -leafRadius; ly <= leafRadius; ly++) {
                            for(let lx = -leafRadius; lx <= leafRadius; lx++) {
                                if(Math.hypot(lx, ly) < leafRadius + 0.5) {
                                    const currentX = x + lx;
                                    const currentY = leafCenterY + ly;
                                    if(game.tileMap[currentY]?.[currentX] === TILE.AIR) {
                                        game.tileMap[currentY][currentX] = TILE.LEAVES;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }

        // ===================================================================================
        // FICHIER : player.js
        // RÔLE : Gère l'état, la physique et le dessin du joueur.
        // ===================================================================================
        class Player {
            constructor(x, y, config, sound) {
                this.x = x; this.y = y;
                this.vx = 0; this.vy = 0;
                this.w = config.player.width; this.h = config.player.height;
                this.hitbox = { offsetX: 3, offsetY: 3, width: 18, height: 21 };
                this.config = config; this.sound = sound;
                this.grounded = false; this.dir = 1;
                this.swingTimer = 0;
                // Noms d'outils corrigés pour correspondre aux assets
                this.tools = ['pickaxe', 'shovel', 'axe', 'sword'];
                this.selectedToolIndex = 0;
                this.inventory = {};
                this.miningTarget = null;
                this.miningProgress = 0;
            }

            getHitbox() {
                return { x: this.x + this.hitbox.offsetX, y: this.y + this.hitbox.offsetY, w: this.hitbox.width, h: this.hitbox.height };
            }

            update(keys, mouse, game) {
                const { physics } = this.config;
                const accel = this.grounded ? physics.groundAcceleration : physics.airAcceleration;

                if (keys.left) { this.vx = Math.max(this.vx - accel, -physics.playerSpeed); this.dir = -1; }
                else if (keys.right) { this.vx = Math.min(this.vx + accel, physics.playerSpeed); this.dir = 1; }
                else { this.vx *= this.grounded ? physics.friction : physics.airResistance; }

                if (keys.jump && this.grounded) { this.vy = -physics.jumpForce; }

                this.vy += physics.gravity;
                if (this.vy > physics.maxFallSpeed) this.vy = physics.maxFallSpeed;

                this.handleCollisions(game);
                this.updateMiningTarget(mouse, game);
                
                if (this.swingTimer > 0) this.swingTimer--;
                if (mouse.left && this.swingTimer <= 0) this.swingTimer = 30;
            }

            updateMiningTarget(mouse, game) {
                const { tileSize, zoom } = game.config;
                const reach = (this.config.player.reach || 4) * tileSize;
                const mouseWorldX = game.camera.x + mouse.x / zoom;
                const mouseWorldY = game.camera.y + mouse.y / zoom;
                
                const dx = mouseWorldX - (this.x + this.w / 2);
                const dy = mouseWorldY - (this.y + this.h / 2);
                
                if (Math.hypot(dx, dy) > reach) {
                    this.miningTarget = null;
                    return;
                }

                const tileX = Math.floor(mouseWorldX / tileSize);
                const tileY = Math.floor(mouseWorldY / tileSize);
                const tileType = game.tileMap[tileY]?.[tileX];

                if (tileType > TILE.AIR) {
                    if (!this.miningTarget || this.miningTarget.x !== tileX || this.miningTarget.y !== tileY) {
                        this.miningTarget = { x: tileX, y: tileY, type: tileType };
                        this.miningProgress = 0;
                    }
                } else {
                    this.miningTarget = null;
                }
            }
            
            handleCollisions(game) {
                const { tileSize } = this.config;
                const map = game.tileMap;
                
                this.x += this.vx;
                let hb = this.getHitbox();
                // Collision X
                if (this.vx > 0) {
                    const tx = Math.floor((hb.x + hb.w) / tileSize);
                    const ty1 = Math.floor(hb.y / tileSize);
                    const ty2 = Math.floor((hb.y + hb.h) / tileSize);
                    if ((map[ty1]?.[tx] > TILE.AIR) || (map[ty2]?.[tx] > TILE.AIR)) {
                        this.x = tx * tileSize - hb.w - this.hitbox.offsetX;
                        this.vx = 0;
                    }
                } else if (this.vx < 0) {
                    const tx = Math.floor(hb.x / tileSize);
                    const ty1 = Math.floor(hb.y / tileSize);
                    const ty2 = Math.floor((hb.y + hb.h) / tileSize);
                     if ((map[ty1]?.[tx] > TILE.AIR) || (map[ty2]?.[tx] > TILE.AIR)) {
                        this.x = (tx + 1) * tileSize - this.hitbox.offsetX;
                        this.vx = 0;
                    }
                }

                this.y += this.vy;
                hb = this.getHitbox();
                this.grounded = false;
                // Collision Y
                if (this.vy > 0) {
                    const ty = Math.floor((hb.y + hb.h) / tileSize);
                    const tx1 = Math.floor(hb.x / tileSize);
                    const tx2 = Math.floor((hb.x + hb.w) / tileSize);
                    if ((map[ty]?.[tx1] > TILE.AIR) || (map[ty]?.[tx2] > TILE.AIR)) {
                        this.y = ty * tileSize - hb.h - this.hitbox.offsetY;
                        this.vy = 0;
                        this.grounded = true;
                    }
                } else if (this.vy < 0) {
                    const ty = Math.floor(hb.y / tileSize);
                    const tx1 = Math.floor(hb.x / tileSize);
                    const tx2 = Math.floor((hb.x + hb.w) / tileSize);
                    if ((map[ty]?.[tx1] > TILE.AIR) || (map[ty]?.[tx2] > TILE.AIR)) {
                        this.y = (ty + 1) * tileSize - this.hitbox.offsetY;
                        this.vy = 0;
                    }
                }
            }

            draw(ctx, assets) {
                const img = assets['player_idle1']; // Utilise un sprite statique pour la démo
                if (!img) return;

                ctx.save();
                if (this.dir === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -this.x - this.w, this.y, this.w, this.h);
                } else {
                    ctx.drawImage(img, this.x, this.y, this.w, this.h);
                }
                ctx.restore();

                const selectedToolName = this.tools[this.selectedToolIndex];
                if (selectedToolName) {
                    const toolAsset = assets[`tool_${selectedToolName}`];
                    if (toolAsset) {
                        ctx.save();
                        const toolSize = this.w * 0.8;
                        const handOffsetX = this.dir === 1 ? this.w * 0.7 : this.w * 0.3;
                        const handOffsetY = this.h * 0.6;
                        const pivotX = this.x + handOffsetX;
                        const pivotY = this.y + handOffsetY;
                        ctx.translate(pivotX, pivotY);
                        if (this.swingTimer > 0) {
                            const progress = (30 - this.swingTimer) / 30;
                            const angle = Math.sin(progress * Math.PI) * -this.dir * 1.5;
                            ctx.rotate(angle);
                        }
                        ctx.drawImage(toolAsset, -toolSize / 2, -toolSize / 2, toolSize, toolSize);
                        ctx.restore();
                    }
                }
            }
        }
        
        // ===================================================================================
        // FICHIER : miningEngine.js
        // RÔLE : Gère la logique de minage des blocs.
        // ===================================================================================
        const BLOCK_BREAK_TIME = {
            [TILE.GRASS]: 0.5, [TILE.DIRT]: 0.5, [TILE.STONE]: 2,
            [TILE.WOOD]: 1.5, [TILE.LEAVES]: 0.3, [TILE.COAL]: 2.5, [TILE.IRON]: 3.5,
        };
        const TOOL_EFFICIENCY = {
            pickaxe: { [TILE.STONE]: 3, [TILE.COAL]: 3, [TILE.IRON]: 3 },
            shovel: { [TILE.DIRT]: 3, [TILE.GRASS]: 3, [TILE.SAND]: 3 },
            axe:    { [TILE.WOOD]: 3, [TILE.LEAVES]: 3 },
        };

        function updateMining(game, keys, mouse, delta) {
            const player = game.player;
            if (!player || !mouse.left || !player.miningTarget) {
                if (player) player.miningProgress = 0;
                game.miningEffect = null;
                return;
            }
            
            const target = player.miningTarget;
            const currentType = game.tileMap[target.y]?.[target.x];
            if (currentType !== target.type || currentType === TILE.AIR) {
                player.miningTarget = null;
                player.miningProgress = 0;
                game.miningEffect = null;
                return;
            }

            const toolName = player.tools[player.selectedToolIndex] || 'hand';
            const breakTime = BLOCK_BREAK_TIME[currentType] || 1;
            const efficiency = TOOL_EFFICIENCY[toolName]?.[currentType] || 0.5;

            const timeToBreak = breakTime / efficiency;
            player.miningProgress += delta / timeToBreak;
            game.miningEffect = { x: target.x, y: target.y, progress: player.miningProgress };

            if (player.miningProgress >= 1) {
                const { tileSize } = game.config;
                game.tileMap[target.y][target.x] = TILE.AIR;
                // Ici, on pourrait ajouter la création d'un objet collectable
                player.miningProgress = 0;
                player.miningTarget = null;
                game.miningEffect = null;
            }
        }

        // ===================================================================================
        // FICHIER : itemIcons.js
        // RÔLE : Dessine les icônes pour la barre d'outils.
        // ===================================================================================
        const itemIconsCache = new Map();
        function getItemIcon(name, assets) {
            if (!itemIconsCache.has(name)) {
                const assetKey = `tool_${name}`;
                if (assets[assetKey]) {
                    itemIconsCache.set(name, assets[assetKey]);
                } else {
                    // Créer une icône placeholder si l'asset n'existe pas
                    const c = document.createElement('canvas');
                    c.width = c.height = 32;
                    const ctx = c.getContext('2d');
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(4, 4, 24, 24);
                    ctx.fillStyle = 'white';
                    ctx.font = "bold 12px monospace";
                    ctx.textAlign = "center";
                    ctx.fillText(name.substring(0, 2).toUpperCase(), 16, 22);
                    const img = new Image();
                    img.src = c.toDataURL();
                    itemIconsCache.set(name, img);
                }
            }
            return itemIconsCache.get(name);
        }

        // ===================================================================================
        // CLASSE PRINCIPALE : Game
        // RÔLE : Orchestre tous les systèmes du jeu.
        // ===================================================================================
        class Game {
            constructor(canvas, config) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.config = config;
                this.assets = {};
                this.keys = { left: false, right: false, jump: false };
                this.mouse = { x: 0, y: 0, left: false, right: false };
                this.camera = { x: 0, y: 0 };
                this.lastTime = 0;
                this.isPaused = true;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.ctx.imageSmoothingEnabled = false;
            }

            async init() {
                await this.loadAssets();
                this.player = new Player(100, 100, this.config, null);
                generateLevel(this, this.config);

                // Placer le joueur au-dessus du sol au point de départ
                const startX = Math.floor(this.tileMap[0].length / 2);
                for (let y = 0; y < this.tileMap.length; y++) {
                    if (this.tileMap[y][startX] > TILE.AIR) {
                        this.player.x = startX * this.config.tileSize;
                        this.player.y = (y - 3) * this.config.tileSize;
                        break;
                    }
                }
                
                this.setupInput();
                this.updateToolbar();
                this.isPaused = false;
            }

            async loadAssets() {
                const assetPromises = [];
                for (const [key, path] of Object.entries(this.config.assets)) {
                    assetPromises.push(new Promise(resolve => {
                        const img = new Image();
                        // Pour la démo, on utilise des placeholders au lieu de chemins de fichiers
                        const [width, height] = [this.config.tileSize, this.config.tileSize];
                        const color = '#' + (Math.random().toString(16) + '000000').substring(2,8);
                        img.src = `https://placehold.co/${width}x${height}/${color}/white?text=${key.slice(0,2)}`;
                        img.onload = () => { this.assets[key] = img; resolve(); };
                        img.onerror = () => { console.warn(`Asset failed: ${key}`); resolve(); };
                    }));
                }
                await Promise.all(assetPromises);
            }

            setupInput() {
                document.addEventListener('keydown', e => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') this.keys.right = true;
                    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') this.keys.jump = true;
                });
                document.addEventListener('keyup', e => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') this.keys.right = false;
                    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') this.keys.jump = false;
                });
                this.canvas.addEventListener('mousedown', e => { if (e.button === 0) this.mouse.left = true; });
                this.canvas.addEventListener('mouseup', e => { if (e.button === 0) this.mouse.left = false; });
                this.canvas.addEventListener('mousemove', e => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                this.canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    if (e.deltaY < 0) this.player.selectedToolIndex--;
                    else this.player.selectedToolIndex++;
                    
                    if (this.player.selectedToolIndex < 0) this.player.selectedToolIndex = this.player.tools.length - 1;
                    if (this.player.selectedToolIndex >= this.player.tools.length) this.player.selectedToolIndex = 0;
                    this.updateToolbar();
                });
            }
            
            update(time) {
                if (this.isPaused || !this.lastTime) {
                    this.lastTime = time;
                    return;
                }
                const delta = (time - this.lastTime) / 1000;
                this.lastTime = time;

                this.player.update(this.keys, this.mouse, this);
                updateMining(this, this.keys, this.mouse, delta);

                // Mise à jour de la caméra pour suivre le joueur
                const { zoom } = this.config;
                this.camera.x = this.player.x - this.canvas.width / (2 * zoom);
                this.camera.y = this.player.y - this.canvas.height / (2 * zoom);
            }

            draw() {
                const { tileSize, zoom } = this.config;
                this.ctx.fillStyle = '#5c94fc'; // Ciel
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.scale(zoom, zoom);
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // Dessiner le monde
                const startX = Math.floor(this.camera.x / tileSize);
                const endX = startX + Math.ceil(this.canvas.width / zoom / tileSize) + 1;
                const startY = Math.floor(this.camera.y / tileSize);
                const endY = startY + Math.ceil(this.canvas.height / zoom / tileSize) + 1;

                for (let y = Math.max(0, startY); y < Math.min(this.tileMap.length, endY); y++) {
                    for (let x = Math.max(0, startX); x < Math.min(this.tileMap[0].length, endX); x++) {
                        const tileType = this.tileMap[y][x];
                        if (tileType > TILE.AIR) {
                            let assetKey;
                            switch(tileType) {
                                case TILE.GRASS: assetKey = 'tile_grass'; break;
                                case TILE.DIRT: assetKey = 'tile_dirt'; break;
                                case TILE.STONE: assetKey = 'tile_stone'; break;
                                case TILE.WOOD: assetKey = 'tile_wood'; break;
                                case TILE.LEAVES: assetKey = 'tile_leaves'; break;
                                default: assetKey = 'tile_stone';
                            }
                            const img = this.assets[assetKey];
                            if (img) this.ctx.drawImage(img, x * tileSize, y * tileSize, tileSize, tileSize);
                        }
                    }
                }
                
                // Dessiner le joueur
                this.player.draw(this.ctx, this.assets);

                // Dessiner l'effet de minage
                if (this.miningEffect) {
                    const {x, y, progress} = this.miningEffect;
                    this.ctx.globalAlpha = 0.5;
                    this.ctx.fillStyle = 'white';
                    const crackSize = tileSize * progress;
                    this.ctx.fillRect(
                        x * tileSize + (tileSize - crackSize) / 2,
                        y * tileSize + (tileSize - crackSize) / 2,
                        crackSize, crackSize
                    );
                    this.ctx.globalAlpha = 1;
                }

                this.ctx.restore();
            }

            updateToolbar() {
                const toolbar = document.getElementById('toolbar');
                toolbar.innerHTML = '';
                this.player.tools.forEach((toolName, index) => {
                    const slot = document.createElement('div');
                    slot.className = 'toolbar-slot';
                    if (index === this.player.selectedToolIndex) {
                        slot.classList.add('selected');
                    }
                    const icon = getItemIcon(toolName, this.assets);
                    if (icon) slot.appendChild(icon);
                    toolbar.appendChild(slot);
                });
            }

            gameLoop(time) {
                this.update(time);
                this.draw();
                requestAnimationFrame(t => this.gameLoop(t));
            }

            start() {
                this.init().then(() => {
                    document.getElementById('mainMenu').classList.remove('active');
                    requestAnimationFrame(t => this.gameLoop(t));
                });
            }
        }

        // ===================================================================================
        // POINT D'ENTRÉE
        // ===================================================================================
        document.addEventListener('DOMContentLoaded', async () => {
            const canvas = document.getElementById('gameCanvas');
            // Charger la config depuis un objet JS au lieu d'un fetch pour la démo
            const config = {
              "tileSize": 16, "zoom": 3, "chunkSize": 16, "worldWidth": 2048, "worldHeight": 1024,
              "generation": { "enemyCount": 10, "treeCount": 30 },
              "physics": { "gravity": 0.35, "jumpForce": 8, "playerSpeed": 3, "friction": 0.85, "airResistance": 0.98, "maxFallSpeed": 10, "groundAcceleration": 0.4, "airAcceleration": 0.2 },
              "player": { "maxLives": 5, "width": 24, "height": 24, "reach": 5 },
              "assets": {
                "tile_grass": "...", "tile_dirt": "...", "tile_stone": "...", "tile_wood": "...", "tile_leaves": "...",
                "tool_pickaxe": "...", "tool_shovel": "...", "tool_axe": "...", "tool_sword": "...",
                "player_idle1": "..."
              }
            };

            const game = new Game(canvas, config);

            document.getElementById('startGame').addEventListener('click', () => {
                game.start();
            });
        });

    </script>
</body>
</html>
