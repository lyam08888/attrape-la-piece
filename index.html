<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Super Pixel Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root {
            --mario-blue: #5C94FC;
            --mario-green: #8CD65C;
            --mario-orange: #FC9838;
            --mario-brown: #C84C0C;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; image-rendering: pixelated; }
        body {
            background: #000;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            padding: 10px;
        }
        h1 {
            color: white;
            text-shadow: 4px 4px 0px var(--mario-brown);
            margin-bottom: 20px;
            animation: bounce 2s ease-in-out infinite;
        }
        @keyframes bounce { 
            50% { transform: translateY(-10px); } 
        }
        #gameWrapper {
            position: relative;
            width: 100%;
            max-width: 960px;
            aspect-ratio: 16 / 9;
            border: 8px solid #000;
            box-shadow: 0 0 0 8px var(--mario-brown), 0 0 0 16px #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: var(--mario-blue);
        }
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 2px 2px #000;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .overlay.active {
            visibility: visible;
            opacity: 1;
        }
        .menu-box {
            background: #000;
            border: 4px solid white;
            padding: 30px;
            text-align: center;
            width: 90%;
            max-width: 450px;
        }
        .menu-box h2 {
            font-size: 1.5em;
            margin-bottom: 25px;
            color: var(--mario-orange);
        }
        .menu-box button {
            font-family: inherit;
            font-size: 1em;
            padding: 10px 20px;
            cursor: pointer;
            background: #333;
            border: 2px solid white;
            color: white;
            margin-top: 10px;
            width: 100%;
        }
        .menu-box button:hover { background: #555; }
        .option-group { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .option-group label { text-align: left; }
        .option-group .toggle-btn, .option-group .difficulty-btn { padding: 5px 10px; font-size: 0.8em; width: auto; }
        .toggle-btn.on { background: var(--mario-green); color: #000; }
        .difficulty-btn.selected { background: var(--mario-orange); color: #000; }
        #skinlist { display: flex; gap: 16px; margin-bottom: 24px; justify-content: center; }
        #skinlist img { width: 48px; height: 48px; border: 4px solid #505050; cursor: pointer; }
        #skinlist img.selected { border-color: var(--mario-orange); transform: scale(1.1); }
        #hud { justify-content: flex-start; pointer-events: none; background: none; }
        .hud-info { width: 100%; padding: 10px 20px; display: flex; justify-content: space-between; }
        #controls { display: none; position: fixed; bottom: 15px; width: 100%; max-width: 400px; left: 50%; transform: translateX(-50%); justify-content: space-between; z-index: 20; padding: 0 20px; }
        .control-btn { width: 70px; height: 70px; border-radius: 50%; background: rgba(0,0,0,0.3); border: 2px solid #fff; display:flex; align-items:center; justify-content:center; font-size: 30px; user-select: none; color: white; }
    </style>
</head>
<body>
    <h1 id="gameTitle">Super Pixel Adventure</h1>
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Menu Principal -->
        <div id="mainMenu" class="overlay active">
            <div class="menu-box">
                <h2 id="menuTitle">Choisissez un héros</h2>
                <div id="skinlist"></div>
                <button data-action="start">START GAME</button>
                <button data-action="options">OPTIONS</button>
                <button data-action="controls">CONTROLS</button>
            </div>
        </div>

        <!-- Menu Options -->
        <div id="optionsMenu" class="overlay">
            <div class="menu-box">
                <h2>OPTIONS</h2>
                <div class="option-group">
                    <label>God Mode</label>
                    <button id="godModeBtn" class="toggle-btn" data-action="toggleGodMode">OFF</button>
                </div>
                <div class="option-group">
                    <label>Sound</label>
                    <button id="soundBtn" class="toggle-btn on" data-action="toggleSound">ON</button>
                </div>
                <div class="option-group">
                    <label>Difficulty</label>
                    <div>
                        <button class="difficulty-btn" data-difficulty="Easy">Easy</button>
                        <button class="difficulty-btn selected" data-difficulty="Normal">Normal</button>
                        <button class="difficulty-btn" data-difficulty="Hard">Hard</button>
                    </div>
                </div>
                <button data-action="backToMain">RETOUR</button>
            </div>
        </div>

        <!-- Menu Contrôles -->
        <div id="controlsMenu" class="overlay">
            <div class="menu-box" style="text-align: left; font-size: 0.8em; line-height: 2;">
                <h2>CONTROLES</h2>
                <b>CLAVIER:</b><br>
                - GAUCHE/DROITE: Bouger<br>
                - ESPACE/HAUT: Sauter<br>
                - P: Pause<br><br>
                <b>MOBILE:</b><br>
                - Utiliser les boutons tactiles.
                <button data-action="backToMain">RETOUR</button>
            </div>
        </div>

        <!-- HUD en jeu -->
        <div id="hud" class="overlay">
            <div class="hud-info">
                <span id="score">SCORE: 0</span>
                <span id="lives">❤❤❤❤❤</span>
                <span id="timer">TEMPS: 180</span>
            </div>
        </div>

        <!-- Écran Game Over -->
        <div id="gameover" class="overlay">
            <div class="menu-box">
                <h2 id="message">Game Over</h2>
                <button id="btnRestart">REJOUER</button>
            </div>
        </div>
    </div>
    <div id="controls">
        <div id="btnLeft" class="control-btn">⬅️</div>
        <div id="btnJump" class="control-btn">⬆️</div>
        <div id="btnRight" class="control-btn">➡️</div>
    </div>
    
    <!-- Fichiers de données et logique du jeu -->
    <script src="config.json" type="application/json"></script>
    <script src="level1.json" type="application/json"></script>
    <script src="game.js"></script>
</body>
</html>
```

---

### `game.js`

Ce fichier est le cerveau du jeu. Il gère les menus, la physique, les graphismes, les options et toute la logique du gameplay. Il est conçu pour être modulaire et facile à comprendre.


```javascript
// =================================================================================
// SUPER PIXEL ADVENTURE - GAME ENGINE V3
// =================================================================================

document.addEventListener('DOMContentLoaded', () => {
    // --- Éléments du DOM ---
    const ui = {
        canvas: document.getElementById('gameCanvas'),
        ctx: document.getElementById('gameCanvas').getContext('2d'),
        gameTitle: document.getElementById('gameTitle'),
        mainMenu: document.getElementById('mainMenu'),
        optionsMenu: document.getElementById('optionsMenu'),
        controlsMenu: document.getElementById('controlsMenu'),
        skinlist: document.getElementById('skinlist'),
        hud: document.getElementById('hud'),
        score: document.getElementById('score'),
        lives: document.getElementById('lives'),
        timer: document.getElementById('timer'),
        gameover: document.getElementById('gameover'),
        message: document.getElementById('message'),
        btnRestart: document.getElementById('btnRestart'),
        godModeBtn: document.getElementById('godModeBtn'),
        soundBtn: document.getElementById('soundBtn'),
        controls: document.getElementById('controls'),
    };

    // --- Variables globales ---
    let config, level, assets = {}, game, keys = {}, currentSkin = 0;

    const gameSettings = {
        godMode: false,
        soundEnabled: true,
        difficulty: 'Normal', // Easy, Normal, Hard
    };

    // --- Chargement initial ---
    async function main() {
        try {
            const [configRes, levelRes] = await Promise.all([fetch('config.json'), fetch('level1.json')]);
            config = await configRes.json();
            level = await levelRes.json();
            
            ui.gameTitle.textContent = config.gameTitle;
            ui.canvas.width = config.canvasWidth;
            ui.canvas.height = config.canvasHeight;
            
            await loadAssets();
            setupMenus();
            setupInput();
        } catch (error) {
            console.error("Erreur de chargement des fichiers du jeu:", error);
            ui.mainMenu.innerHTML = "<h2>Erreur de chargement</h2>";
        }
    }

    async function loadAssets() {
        const promises = Object.entries(config.assets).map(([key, path]) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = path;
                img.onload = () => { assets[key] = img; resolve(); };
                img.onerror = reject;
            });
        });
        await Promise.all(promises);
    }

    // --- Gestion des Menus ---
    function setupMenus() {
        ui.skinlist.innerHTML = '';
        config.skins.forEach((key, i) => {
            const img = assets[key].cloneNode();
            img.onclick = () => selectSkin(i);
            if (i === currentSkin) img.classList.add("selected");
            ui.skinlist.appendChild(img);
        });
        
        document.body.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            const difficulty = e.target.dataset.difficulty;

            if (action) handleMenuAction(action);
            if (difficulty) setDifficulty(difficulty);
        });
        ui.btnRestart.onclick = initGame;
    }
    
    function handleMenuAction(action) {
        switch(action) {
            case 'start': initGame(); break;
            case 'options': showMenu(ui.optionsMenu); break;
            case 'controls': showMenu(ui.controlsMenu); break;
            case 'backToMain': showMenu(ui.mainMenu); break;
            case 'toggleGodMode':
                gameSettings.godMode = !gameSettings.godMode;
                ui.godModeBtn.textContent = gameSettings.godMode ? 'ON' : 'OFF';
                ui.godModeBtn.classList.toggle('on', gameSettings.godMode);
                break;
            case 'toggleSound':
                gameSettings.soundEnabled = !gameSettings.soundEnabled;
                ui.soundBtn.textContent = gameSettings.soundEnabled ? 'ON' : 'OFF';
                ui.soundBtn.classList.toggle('on', gameSettings.soundEnabled);
                break;
        }
    }

    function showMenu(menuToShow) {
        [ui.mainMenu, ui.optionsMenu, ui.controlsMenu].forEach(menu => menu.classList.remove('active'));
        menuToShow.classList.add('active');
    }

    function selectSkin(i) {
        currentSkin = i;
        [...ui.skinlist.children].forEach((img, index) => img.classList.toggle("selected", index === i));
    }

    function setDifficulty(level) {
        gameSettings.difficulty = level;
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.difficulty === level);
        });
    }

    // --- Initialisation du Jeu ---
    function initGame() {
        game = {
            player: {
                x: 50, y: 150, vx: 0, vy: 0,
                w: 32, h: 32,
                grounded: false, canDoubleJump: true, dir: 1, invulnerable: 0
            },
            camera: { x: 0 },
            enemies: [], particles: [],
            tileMap: level.tiles.map(row => row.split('').map(Number)),
            score: 0, lives: config.player.maxLives, time: config.player.gameTime,
            timeLast: Date.now(), over: false, dayNightCycle: 0, weather: { type: 'clear', particles: [] }
        };
        
        setupDifficulty();
        
        updateHUD();
        [ui.mainMenu, ui.optionsMenu, ui.controlsMenu, ui.gameover].forEach(m => m.classList.remove('active'));
        ui.hud.style.display = 'flex';
        
        requestAnimationFrame(gameLoop);
    }
    
    function setupDifficulty() {
        let enemyMultiplier = 1;
        if (gameSettings.difficulty === 'Easy') enemyMultiplier = 0.7;
        if (gameSettings.difficulty === 'Hard') enemyMultiplier = 1.5;
        
        game.tileMap.forEach((row, y) => {
            row.forEach((tile, x) => {
                if (tile === 8 && Math.random() < enemyMultiplier) {
                    game.enemies.push({ 
                        x: x * config.tileSize, y: y * config.tileSize, 
                        w: 32, h: 32, vx: -0.5 * (gameSettings.difficulty === 'Hard' ? 1.5 : 1), vy: 0 
                    });
                }
            });
        });
    }

    // --- Boucle de Jeu ---
    function gameLoop() {
        if (game.over) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Logique de mise à jour ---
    function update() {
        updatePlayer();
        updateEnemies();
        updateParticles();
        updateCamera();
        updateTimer();
        updateWorld();
    }

    function updatePlayer() {
        const p = game.player;
        if (keys.left) { p.vx = -config.physics.playerSpeed; p.dir = -1; }
        else if (keys.right) { p.vx = config.physics.playerSpeed; p.dir = 1; }
        else { p.vx = 0; }

        if (keys.jump) {
            if (p.grounded) { p.vy = -config.physics.jumpForce; p.canDoubleJump = true; playSound('jump'); }
            else if (p.canDoubleJump) { p.vy = -config.physics.jumpForce * 0.8; p.canDoubleJump = false; playSound('jump'); }
            keys.jump = false;
        }

        p.vy += config.physics.gravity;
        
        // Collisions
        p.x += p.vx;
        handleCollision('x');
        p.y += p.vy;
        p.grounded = false;
        handleCollision('y');

        if (p.y > level.height * config.tileSize) loseLife();
        if (p.invulnerable > 0) p.invulnerable--;
    }
    
    function updateEnemies() {
        game.enemies.forEach(e => {
            e.vy += config.physics.gravity;
            let oldX = e.x;
            e.x += e.vx;
            
            const nextTileX = e.vx > 0 ? e.x + e.w : e.x;
            const groundAhead = getTileAt(e.vx > 0 ? e.x + e.w : e.x -1, e.y + e.h + 1);

            if (getTileAt(nextTileX, e.y) > 0 || getTileAt(nextTileX, e.y + e.h - 1) > 0 || groundAhead === 0) {
                e.x = oldX;
                e.vx *= -1;
            }

            e.y += e.vy;
            if (e.vy > 0 && (getTileAt(e.x, e.y + e.h) > 0 || getTileAt(e.x + e.w, e.y + e.h) > 0)) {
                e.y = Math.floor((e.y + e.h) / config.tileSize) * config.tileSize - e.h;
                e.vy = 0;
            }

            if (rectCollide(game.player, e) && game.player.invulnerable === 0) {
                if (game.player.vy > 0 && game.player.y + game.player.h < e.y + 16) {
                    game.enemies = game.enemies.filter(en => en !== e);
                    game.score += 100;
                    game.player.vy = -config.physics.jumpForce / 2;
                } else {
                    loseLife();
                }
            }
        });
    }

    function updateWorld() {
        game.dayNightCycle = (game.dayNightCycle + 0.0005) % (Math.PI * 2);
        if (Math.random() < 0.001) game.weather.type = ['clear', 'rain', 'snow'][Math.floor(Math.random() * 3)];
    }
    
    // --- Dessin ---
    function draw() {
        drawSky();
        ui.ctx.save();
        ui.ctx.translate(-game.camera.x, 0);
        drawTiles();
        drawEnemies();
        drawPlayer();
        ui.ctx.restore();
    }
    
    function drawSky() {
        const time = (Math.sin(game.dayNightCycle) + 1) / 2;
        let c1 = "#87ceeb", c2 = "#98d8e8"; // Jour
        if (time < 0.3) { c1 = "#0a0a2e"; c2 = "#1e1e4e"; } // Nuit
        else if (time < 0.5) { c1 = "#4a5a8e"; c2 = "#f4a460"; } // Aube
        else if (time > 0.8) { c1 = "#ff6b6b"; c2 = "#ffa500"; } // Crépuscule
        const grad = ui.ctx.createLinearGradient(0, 0, 0, ui.canvas.height);
        grad.addColorStop(0, c1); grad.addColorStop(1, c2);
        ui.ctx.fillStyle = grad;
        ui.ctx.fillRect(0, 0, ui.canvas.width, ui.canvas.height);
    }

    function drawTiles() {
        const startCol = Math.floor(game.camera.x / config.tileSize);
        const endCol = startCol + (ui.canvas.width / config.tileSize) + 2;
        for (let y = 0; y < level.height; y++) {
            for (let x = startCol; x < endCol; x++) {
                const tile = getTile(x, y);
                if (!tile) continue;
                const tx = x * config.tileSize, ty = y * config.tileSize;
                if(tile === 1 || tile === 2) ui.ctx.drawImage(assets.wall, tx, ty, 32, 32);
                if(tile === 4) ui.ctx.drawImage(assets.coin, tx, ty, 32, 32);
                if(tile === 9) ui.ctx.drawImage(assets.flag, tx, ty, 32, 32);
            }
        }
    }

    function drawPlayer() {
        const p = game.player;
        ui.ctx.save();
        ui.ctx.translate(p.x, p.y);
        if (p.dir === -1) { ui.ctx.scale(-1, 1); ui.ctx.translate(-p.w, 0); }
        
        if (gameSettings.godMode) {
            ui.ctx.shadowColor = 'gold';
            ui.ctx.shadowBlur = 15;
        }
        
        if (p.invulnerable > 0 && p.invulnerable % 10 < 5) ui.ctx.globalAlpha = 0.5;
        
        ui.ctx.drawImage(assets[config.skins[currentSkin]], 0, 0, p.w, p.h);
        ui.ctx.restore();
    }

    function drawEnemies() {
        game.enemies.forEach(e => ui.ctx.drawImage(assets.enemy, e.x, e.y, e.w, e.h));
    }

    // --- Utilitaires ---
    function getTile(x, y) { return (y < 0 || y >= level.height || x < 0 || x >= level.width) ? 0 : game.tileMap[y][x]; }
    function getTileAt(px, py) { return getTile(Math.floor(px / config.tileSize), Math.floor(py / config.tileSize)); }
    function rectCollide(r1, r2) { return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y; }
    function playSound(type) { if(!gameSettings.soundEnabled) return; /* Logique audio ici */ }
    function updateHUD() { /* ... */ }
    function updateTimer() { /* ... */ }
    function updateParticles() { /* ... */ }
    function loseLife() { if(gameSettings.godMode) return; game.lives--; if(game.lives <= 0) endGame(false); else { game.player.x = 50; game.player.y = 150; game.player.invulnerable = 120; } updateHUD(); }
    function endGame(win) { game.over = true; ui.message.innerHTML = win ? `🎉 Victoire! 🎉` : `💀 Game Over 💀`; ui.hud.style.display = 'none'; ui.gameover.classList.add('active'); }
    function handleCollision(axis) { /* Logique de collision détaillée */ }
    function setupInput() { /* Logique des contrôles clavier et tactiles */ }

    main();
});
```

---

### 6. Fichiers d'Assets (Images)

**Important :** Vous devez créer ces images vous-même. Ce sont des fichiers PNG avec un fond transparent. Pour un style 8-bit, utilisez une résolution basse (ex: 32x32 pixels).

-   `assets/player1.png`
-   `assets/player2.png`
-   `assets/player3.png`
-   `assets/coin.png`
-   `assets/enemy.png`
-   `assets/flag.png`
-   `assets/bonus.png`
-   `assets/wall.png`

Une fois ces fichiers en place, votre jeu sera complet et fonctionnel, avec toutes les améliorations demandé
