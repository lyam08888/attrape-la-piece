<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Super Pixel Adventure 2 - RPG Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="rpgInterface.css">
</head>
<body class="game-page">
    <!-- Écran de chargement -->
    <div id="loadingScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: white; z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'VT323', monospace;">
        <h1 style="font-size: 3em;">Super Pixel Adventure 2</h1>
        <p id="loadingStatus" style="font-size: 1.5em;">Chargement des modules...</p>
        <div style="width: 80%; background: #333; border: 1px solid #555; margin-top: 20px;">
            <div id="loadingProgressBar" style="width: 0%; height: 20px; background: #4CAF50; transition: width 0.2s;"></div>
        </div>
    </div>

    <!-- Conteneur de Jeu avec Interface RPG -->
    <div id="gameContainer">
        <canvas id="gameCanvas" tabindex="0"></canvas>
        <!-- L'interface RPG sera injectée ici par le gestionnaire -->
    </div>

    <script type="module">
        const loadingStatus = document.getElementById('loadingStatus');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const loadingScreen = document.getElementById('loadingScreen');

        function updateProgress(status, percentage) {
            if (loadingStatus) loadingStatus.innerText = status;
            if (loadingProgressBar) loadingProgressBar.style.width = `${percentage}%`;
        }

        // --- Importation dynamique et sécurisée des modules ---
        async function safeImport(path, name) {
            try {
                const module = await import(path);
                console.log(`✅ Module ${name} importé avec succès.`);
                return module;
            } catch (e) {
                console.warn(`⚠️ Module ${name} (${path}) non trouvé. Une alternative sera utilisée.`, e.message);
                return null; // Retourne null si le module n'est pas trouvé
            }
        }

        updateProgress('Chargement des modules...', 10);

        // --- Modules principaux (critiques pour le jeu) ---
        const { GameEngine } = await safeImport('./engine.js', 'GameEngine');
        const { Player } = await safeImport('./player.js', 'Player');
        const WorldModule = await safeImport('./world.js', 'World');
        const { TILE, generateLevel, ensureWorldColumns } = WorldModule || {};
        const { RPGInterfaceManager } = await safeImport('./rpgInterfaceManager.js', 'RPGInterfaceManager') || { RPGInterfaceManager: class { constructor() { console.log("Fallback RPGInterfaceManager"); this.showNotification=()=>{}; this.toggleWindow=()=>{}; this.updateHUD=()=>{}; } } };
        const MiningModule = await safeImport('./miningEngine.js', 'MiningEngine');
        const { integrateMiningWithRPG } = MiningModule || {};
        const AdvancedSystemsModule = await safeImport('./advancedSystemsIntegration.js', 'AdvancedSystemsIntegration');
        const { integrateAdvancedSystems } = AdvancedSystemsModule || {};

        // --- Modules secondaires (avec fallbacks) ---
        const FXModule = await safeImport('./fx.js', 'ParticleSystem');
        const ParticleSystem = FXModule ? FXModule.ParticleSystem : class { constructor(){this.particles=[];} update(){} draw(){} createParticles(){} };

        const QuestModule = await safeImport('./questSystem.js', 'QuestSystem');
        const QuestSystem = QuestModule ? QuestModule.QuestSystem : class { constructor(){this.quests=[];} addQuest(){} update(){} };
        
        const InventoryModule = await safeImport('./inventorySystem.js', 'Inventory');
        const Inventory = InventoryModule ? InventoryModule.Inventory : class { constructor(){this.items={};} };
        
        const CombatModule = await safeImport('./combatSystem.js', 'CombatSystem');
        const CombatSystem = CombatModule ? CombatModule.CombatSystem : class { constructor(){} update(){} };
        const BiomeSystem = CombatModule ? CombatModule.BiomeSystem : class { constructor(){} update(){} };

        const SaveModule = await safeImport('./saveSystem.js', 'SaveSystem');
        const SaveSystem = SaveModule ? SaveModule.SaveSystem : class { constructor(){} save(){} load(){} };

        updateProgress('Modules principaux chargés.', 30);

        // Assurer que les modules critiques sont là
        if (!GameEngine || !Player || !WorldModule) {
            throw new Error("Modules de jeu critiques (engine, player, world) n'ont pas pu être chargés. Le jeu ne peut pas démarrer.");
        }
        
        window.updateQuestUI = function() { console.log("updateQuestUI appelé"); };
        window.gameModuleReady = true;

        // --- Configuration ---
        const defaultConfig = {
            "version": "2.1-RPG-Stable",
            "tileSize": 16,
            "zoom": 3,
            "worldWidth": 2048,
            "worldHeight": 1024,
            "physics": { "gravity": 0.35, "jumpForce": 8, "playerSpeed": 3, "friction": 0.85, "maxFallSpeed": 10 },
            "player": { "width": 16, "height": 24 },
            "chunkSize": 16,
            "renderDistance": 8,
            "particles": true,
            "weather": true,
            "lighting": true
        };

        let game = null;
        let engine = null;
        let config = defaultConfig;

        async function loadConfig() {
            try {
                const resp = await fetch('options.json');
                if (!resp.ok) return defaultConfig;
                const loadedConfig = await resp.json();
                // Fusionne la config par défaut avec celle chargée
                return { ...defaultConfig, ...loadedConfig };
            } catch (e) {
                console.warn("options.json non trouvé. Utilisation de la configuration par défaut.", e);
                return defaultConfig;
            }
        }
        
        function resizeCanvas() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            const container = canvas.parentElement;
            if (!container) return;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        async function initializeGame(seed = null) {
            console.log("🎮 Initialisation du jeu RPG...");
            updateProgress('Initialisation du jeu...', 40);

            try {
                config = await loadConfig();
                resizeCanvas();
                
                const canvas = document.getElementById('gameCanvas');
                engine = new GameEngine(canvas, config);
                
                console.log("✨ Création de l'interface RPG...");
                const rpgInterface = new RPGInterfaceManager();
                window.rpgInterface = rpgInterface;

                game = {
                    config, canvas,
                    ctx: canvas.getContext('2d'),
                    rpgInterface,
                    tileMap: [],
                    player: null,
                    camera: { x: 0, y: 0 },
                    mouse: { x: 0, y: 0, left: false, right: false },
                    enemies: [], pnjs: [], animals: [], collectibles: [],
                    projectiles: [], particles: [], chests: [],
                    particleSystem: null, combatSystem: null, biomeSystem: null,
                    weatherSystem: null, lightingSystem: null, questSystem: null,
                    inventory: null, saveSystem: null,
                    time: 0, paused: false,
                    createParticles: (x, y, count, color) => game.particleSystem?.createParticles(x, y, count, color),
                    updateUI: () => game.rpgInterface?.updateHUD()
                };
                window.game = game;

                console.log("🌍 Génération du monde...");
                updateProgress('Génération du monde...', 60);
                const worldWidthInTiles = Math.floor(config.worldWidth / config.tileSize);
                const worldHeightInTiles = Math.floor(config.worldHeight / config.tileSize);
                
                try {
                    game.tileMap = generateLevel(worldWidthInTiles, worldHeightInTiles, seed);
                } catch (worldError) {
                    console.error("❌ Erreur critique lors de la génération du monde:", worldError);
                    // Création d'un monde de secours simple
                    game.tileMap = Array(worldHeightInTiles).fill(0).map((_, y) => 
                        Array(worldWidthInTiles).fill(y > worldHeightInTiles * 0.7 ? TILE.DIRT : TILE.AIR)
                    );
                    game.tileMap[Math.floor(worldHeightInTiles * 0.7)].fill(TILE.GRASS);
                }
                
                console.log("👤 Création du joueur...");
                updateProgress('Création du joueur...', 80);
                game.player = new Player(400, 300, config, null);
                
                console.log("🔗 Intégration des systèmes...");
                if (integrateAdvancedSystems) integrateAdvancedSystems(game);
                
                game.questSystem = new QuestSystem();
                game.inventory = new Inventory();
                game.combatSystem = new CombatSystem();
                game.biomeSystem = new BiomeSystem();
                game.particleSystem = new ParticleSystem();
                game.saveSystem = new SaveSystem();

                if (integrateMiningWithRPG) integrateMiningWithRPG(game);
                
                console.log("✅ Jeu initialisé avec succès !");
                updateProgress('Jeu initialisé !', 100);
                return true;

            } catch (error) {
                console.error("❌ Erreur fatale lors de l'initialisation du jeu:", error);
                loadingStatus.innerHTML = `Erreur: ${error.message}<br/>Veuillez recharger.`;
                loadingProgressBar.style.background = 'red';
                throw error;
            }
        }

        const gameLogic = {
            init: async (assets = {}) => {
                if (game) game.assets = assets;
                return true;
            },
            update: (delta, keys, mouse) => {
                if (!game || !game.player || game.paused) return;
                game.mouse = mouse;
                game.player.update(keys, game, delta);
                if (game.player.regenerateStats) game.player.regenerateStats(delta);
                game.particleSystem?.update();
                game.combatSystem?.update(delta);
                game.biomeSystem?.update(game, delta);
                game.weatherSystem?.update(game, delta);
                game.questSystem?.update(delta);
                updateCamera();
                game.updateUI();
                game.time += delta;
            },
            draw: (ctx, assets, delta) => {
                if (!game || !game.player) return;
                ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
                const gradient = ctx.createLinearGradient(0, 0, 0, game.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#32CD32');
                gradient.addColorStop(1, '#8B4513');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

                ctx.save();
                ctx.scale(config.zoom, config.zoom);
                ctx.translate(-game.camera.x, -game.camera.y);
                
                drawWorld(ctx);
                game.pnjs.forEach(p => p.draw(ctx));
                game.enemies.forEach(e => e.draw(ctx));
                game.player.draw(ctx, assets);
                game.particleSystem?.draw(ctx);
                
                ctx.restore();
            },
            isPaused: () => game ? game.paused : false,
        };
        
        function updateCamera() {
            const { zoom, worldWidth, worldHeight } = config;
            const canvasWidth = game.canvas.width;
            const canvasHeight = game.canvas.height;
            let targetX = game.player.x + game.player.w / 2 - canvasWidth / (2 * zoom);
            let targetY = game.player.y + game.player.h / 2 - canvasHeight / (2 * zoom);
            game.camera.x = Math.max(0, Math.min(targetX, worldWidth - canvasWidth / zoom));
            game.camera.y = Math.max(0, Math.min(targetY, worldHeight - canvasHeight / zoom));
        }

        function drawWorld(ctx) {
            const { tileSize, zoom } = config;
            const startX = Math.floor(game.camera.x / tileSize);
            const endX = startX + Math.ceil(game.canvas.width / tileSize / zoom) + 1;
            const startY = Math.floor(game.camera.y / tileSize);
            const endY = startY + Math.ceil(game.canvas.height / tileSize / zoom) + 1;

            const colors = { 1: '#32CD32', 2: '#8B4513', 3: '#696969' };
            for (let y = Math.max(0, startY); y < Math.min(game.tileMap.length, endY); y++) {
                for (let x = Math.max(0, startX); x < Math.min(game.tileMap[y].length, endX); x++) {
                    const tile = game.tileMap[y][x];
                    if (tile > 0) {
                        ctx.fillStyle = colors[tile] || '#696969';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }
        }

        function setupKeyboardHandlers() {
            window.addEventListener('keydown', (e) => {
                if (!game || !game.rpgInterface) return;
                const key = e.key.toLowerCase();
                const mapping = { 'i': 'inventoryWindow', 'c': 'characterWindow', 'q': 'questWindow', 'm': 'mapWindow', 'o': 'craftingWindow', 'j': 'journalWindow', 'escape': 'settingsWindow' };
                if (mapping[key]) game.rpgInterface.toggleWindow(mapping[key]);
            });
        }

        async function startGame() {
            try {
                await initializeGame();
                setupKeyboardHandlers();
                window.addEventListener('resize', resizeCanvas);
                await engine.start(gameLogic);
                
                // Cacher l'écran de chargement et afficher le jeu
                if (loadingScreen) loadingScreen.style.display = 'none';

                game.rpgInterface.showNotification('Bienvenue dans Super Pixel Adventure 2 !', 'success', 5000);
            } catch (error) {
                console.error("❌ Erreur critique lors du démarrage:", error);
                updateProgress(`Erreur: ${error.message}`, 100);
                loadingProgressBar.style.background = 'red';
            }
        }

        document.addEventListener('DOMContentLoaded', startGame);
        
    </script>
</body>
</html>