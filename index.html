<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Pixel Adventure 2 - RPG Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="rpgInterface.css">
</head>
<body class="game-page">
    <!-- Conteneur de Jeu avec Interface RPG -->
    <div id="gameContainer">
        <canvas id="gameCanvas" tabindex="0"></canvas>
        <!-- L'interface RPG sera inject√©e ici par le gestionnaire -->
    </div>

    <script type="module">
        // FIXED: Improved error handling and module loading
        async function loadModules() {
            try {
                // Import des modules ES6 avec gestion d'erreurs
                const modules = await Promise.allSettled([
                    import('./engine.js'),
                    import('./player.js'),
                    import('./world.js'),
                    import('./rpgInterfaceManager.js'),
                    import('./fx.js'),
                    import('./advancedSystemsIntegration.js')
                ]);

                // V√©rifier que les modules critiques sont charg√©s
                const criticalModules = ['engine.js', 'player.js', 'world.js', 'rpgInterfaceManager.js'];
                const failedCritical = modules.slice(0, 4).some(result => result.status === 'rejected');
                
                if (failedCritical) {
                    throw new Error('√âchec du chargement des modules critiques');
                }

                return {
                    GameEngine: modules[0].value.GameEngine,
                    Player: modules[1].value.Player,
                    world: modules[2].value,
                    RPGInterfaceManager: modules[3].value.RPGInterfaceManager,
                    ParticleSystem: modules[4].status === 'fulfilled' ? modules[4].value.ParticleSystem : null,
                    integrateAdvancedSystems: modules[5].status === 'fulfilled' ? modules[5].value.integrateAdvancedSystems : null
                };
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des modules:', error);
                throw error;
            }
        }

        // Configuration par d√©faut
        const defaultConfig = {
            "version": "2.0-RPG",
            "tileSize": 16,
            "zoom": 3,
            "worldWidth": 2048,
            "worldHeight": 1024,
            "generation": { "enemyCount": 10, "treeCount": 20 },
            "physics": {
                "gravity": 0.35,
                "jumpForce": 8,
                "playerSpeed": 3,
                "friction": 0.85,
                "airResistance": 0.98,
                "maxFallSpeed": 10,
                "groundAcceleration": 0.4,
                "airAcceleration": 0.2,
                "wallSlideSpeed": 1.5,
                "wallJumpForce": 6,
                "glideGravity": 0.1,
                "glideFallSpeed": 0.5
            },
            "player": {
                "width": 16,
                "height": 24,
                "hitbox": {
                    "offsetX": 2,
                    "offsetY": 4,
                    "width": 12,
                    "height": 20
                }
            },
            "playerAnimations": {
                "idle": ["player_idle1"],
                "walking": ["player_walk1", "player_walk2"],
                "running": ["player_run1", "player_run2"],
                "jumping": ["player_jump"]
            },
            "chunkSize": 16,
            "renderDistance": 8,
            "particles": true,
            "weather": true,
            "lighting": true,
            "mobileMode": false
        };

        // Variables globales
        let game = null;
        let engine = null;
        let config = defaultConfig;
        let gameModules = null;

        // Fonction pour charger la configuration
        async function loadConfig() {
            try {
                const resp = await fetch('config.json');
                if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
                const loadedConfig = await resp.json();
                config = { ...defaultConfig, ...loadedConfig };
                return config;
            } catch (e) {
                console.warn("Impossible de charger config.json. Utilisation de la configuration par d√©faut.", e);
                return defaultConfig;
            }
        }

        // Fonction pour redimensionner le canvas
        function resizeCanvas() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;

            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        // Fonction principale d'initialisation du jeu
        async function initializeGame(seed = null) {
            console.log("üéÆ Initialisation du jeu RPG...");
            
            try {
                // Charger les modules
                console.log("üì¶ Chargement des modules...");
                gameModules = await loadModules();
                
                // Charger la configuration
                config = await loadConfig();
                console.log("‚úÖ Configuration charg√©e");

                // Redimensionner le canvas
                resizeCanvas();
                
                // Cr√©er le moteur de jeu
                engine = new gameModules.GameEngine(document.getElementById('gameCanvas'), config);
                
                // Initialiser l'interface RPG compl√®te
                console.log("üéÆ Initialisation de l'interface RPG...");
                const rpgInterface = new gameModules.RPGInterfaceManager();
                window.rpgInterface = rpgInterface;
                
                // Cr√©er l'objet game
                game = {
                    config: config,
                    canvas: document.getElementById('gameCanvas'),
                    ctx: document.getElementById('gameCanvas').getContext('2d'),
                    rpgInterface: rpgInterface,
                    
                    // Syst√®mes de base
                    tileMap: [],
                    player: null,
                    camera: { x: 0, y: 0 },
                    mouse: { x: 0, y: 0, left: false, right: false },
                    
                    // Entit√©s
                    enemies: [],
                    pnjs: [],
                    animals: [],
                    collectibles: [],
                    projectiles: [],
                    particles: [],
                    chests: [],
                    
                    // Syst√®mes avanc√©s
                    particleSystem: null,
                    combatSystem: null,
                    biomeSystem: null,
                    weatherSystem: null,
                    lightingSystem: null,
                    questSystem: null,
                    inventory: null,
                    saveSystem: null,
                    
                    // √âtat du jeu
                    time: 0,
                    paused: false,
                    
                    // Fonctions utilitaires
                    createParticles: function(x, y, count, color) {
                        if (this.particleSystem) {
                            this.particleSystem.createParticles(x, y, count, color);
                        }
                    },
                    
                    updateUI: function() {
                        if (this.rpgInterface) {
                            this.rpgInterface.updateHUD();
                        }
                    }
                };
                
                window.game = game;
                
                // FIXED: G√©n√©rer le monde avec les bons param√®tres
                console.log("üåç G√©n√©ration du monde...");
                const worldWidthInTiles = Math.floor(config.worldWidth / config.tileSize);
                const worldHeightInTiles = Math.floor(config.worldHeight / config.tileSize);
                game.tileMap = gameModules.world.generateLevel(worldWidthInTiles, worldHeightInTiles, seed);
                
                // Cr√©er le joueur
                console.log("üë§ Cr√©ation du joueur...");
                game.player = new gameModules.Player(400, 300, config, null);
                
                // Int√©grer les syst√®mes avanc√©s si disponibles
                try {
                    if (gameModules.integrateAdvancedSystems) {
                        gameModules.integrateAdvancedSystems(game);
                        console.log("‚úÖ Syst√®mes avanc√©s int√©gr√©s !");
                    }
                } catch (error) {
                    console.warn("‚ö†Ô∏è Erreur int√©gration syst√®mes avanc√©s:", error);
                }
                
                // Initialiser les syst√®mes RPG de base
                initializeBasicRPGSystems();
                
                console.log("‚úÖ Jeu RPG initialis√© avec succ√®s !");
                return true;
                
            } catch (error) {
                console.error("‚ùå Erreur lors de l'initialisation du jeu:", error);
                throw error;
            }
        }

        // Fonction pour initialiser les syst√®mes RPG de base
        function initializeBasicRPGSystems() {
            console.log("üéØ Initialisation des syst√®mes RPG de base...");
            
            try {
                // Syst√®me de particules de base
                if (gameModules.ParticleSystem) {
                    game.particleSystem = new gameModules.ParticleSystem();
                } else {
                    // Fallback simple
                    game.particleSystem = {
                        particles: [],
                        createParticles: function(x, y, count, color) {
                            console.log(`Particules cr√©√©es: ${count} √† (${x}, ${y})`);
                        },
                        update: function() {},
                        draw: function(ctx) {}
                    };
                }
                
                // Syst√®mes de base simul√©s
                game.questSystem = {
                    quests: [],
                    addQuest: function(quest) {
                        this.quests.push(quest);
                        console.log(`Qu√™te ajout√©e: ${quest.title}`);
                    },
                    update: function(delta) {}
                };
                
                game.inventory = {
                    items: {},
                    addItem: function(item, count) {
                        this.items[item] = (this.items[item] || 0) + count;
                    }
                };
                
                console.log("‚úÖ Syst√®mes RPG de base initialis√©s !");
                
            } catch (error) {
                console.warn("‚ö†Ô∏è Erreur lors de l'initialisation des syst√®mes RPG de base:", error);
            }
        }

        // Logique de jeu principale
        const gameLogic = {
            async init(assets = {}) {
                console.log("Initialisation de la logique de jeu...");
                
                // Le jeu est d√©j√† initialis√© par initializeGame()
                game.assets = assets;
                
                return true;
            },

            update(delta, keys, mouse) {
                if (!game || !game.player || game.paused) return;
                
                try {
                    // FIXED: Update mouse position in game object
                    if (mouse) {
                        game.mouse = mouse;
                    }
                    
                    // Mettre √† jour le joueur
                    game.player.update(keys, game, delta);
                    
                    // R√©g√©n√©ration des stats RPG
                    if (game.player.regenerateStats) {
                        game.player.regenerateStats(delta);
                    }
                    
                    // Mettre √† jour les syst√®mes
                    if (game.particleSystem && game.particleSystem.update) {
                        game.particleSystem.update(delta);
                    }
                    if (game.combatSystem && game.combatSystem.update) {
                        game.combatSystem.update(delta);
                    }
                    if (game.questSystem && game.questSystem.update) {
                        game.questSystem.update(delta);
                    }
                    
                    // Mettre √† jour la cam√©ra
                    updateCamera();
                    
                    // Mettre √† jour l'interface
                    game.updateUI();
                    
                    // Mettre √† jour le temps
                    game.time += delta;
                    
                } catch (error) {
                    console.error("Erreur dans la mise √† jour du jeu:", error);
                }
            },

            draw(ctx, assets, delta) {
                if (!game || !game.player) return;
                
                try {
                    // Effacer le canvas
                    ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
                    
                    // Dessiner le fond d√©grad√© (Paradis √† Enfer)
                    const gradient = ctx.createLinearGradient(0, 0, 0, game.canvas.height);
                    gradient.addColorStop(0, '#FFE4B5');    // Paradis
                    gradient.addColorStop(0.15, '#87CEEB'); // Ciel
                    gradient.addColorStop(0.3, '#32CD32');  // For√™ts
                    gradient.addColorStop(0.45, '#9370DB'); // Cristaux
                    gradient.addColorStop(0.6, '#DAA520');  // Plaines
                    gradient.addColorStop(0.75, '#8B4513'); // Terres sombres
                    gradient.addColorStop(0.9, '#8B0000');  // Enfer
                    gradient.addColorStop(1, '#000000');    // Abysse
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
                    
                    // Appliquer la transformation de cam√©ra
                    ctx.save();
                    ctx.translate(-game.camera.x, -game.camera.y);
                    
                    // Dessiner le monde
                    drawWorld(ctx);
                    
                    // Dessiner les entit√©s
                    drawEntities(ctx);
                    
                    // Dessiner le joueur
                    drawPlayer(ctx);
                    
                    // Dessiner les particules
                    if (game.particleSystem && game.particleSystem.draw) {
                        game.particleSystem.draw(ctx);
                    }
                    
                    ctx.restore();
                    
                } catch (error) {
                    console.error("Erreur dans le rendu du jeu:", error);
                }
            },

            // FIXED: Add isPaused method
            isPaused() {
                return game ? game.paused : false;
            }
        };

        // Fonction de mise √† jour de la cam√©ra
        function updateCamera() {
            const { zoom, worldWidth, worldHeight } = config;
            const canvasWidth = game.canvas.width || 800;
            const canvasHeight = game.canvas.height || 600;

            let targetX = game.player.x + game.player.w / 2 - canvasWidth / 2 / zoom;
            let targetY = game.player.y + game.player.h / 2 - canvasHeight / 2 / zoom;

            const maxCameraX = Math.max(0, worldWidth - (canvasWidth / zoom));
            const maxCameraY = Math.max(0, worldHeight - (canvasHeight / zoom));

            game.camera.x = Math.max(0, Math.min(targetX, maxCameraX));
            game.camera.y = Math.max(0, Math.min(targetY, maxCameraY));
        }

        // Fonction de rendu du monde
        function drawWorld(ctx) {
            const { tileSize, zoom } = config;
            
            // Calculer la zone visible
            const startX = Math.floor(game.camera.x / tileSize) - 1;
            const endX = startX + Math.ceil(game.canvas.width / tileSize / zoom) + 2;
            const startY = Math.floor(game.camera.y / tileSize) - 1;
            const endY = startY + Math.ceil(game.canvas.height / tileSize / zoom) + 2;
            
            for (let y = Math.max(0, startY); y < Math.min(game.tileMap.length, endY); y++) {
                for (let x = Math.max(0, startX); x < Math.min(game.tileMap[0]?.length || 0, endX); x++) {
                    const tileType = game.tileMap[y]?.[x];
                    if (tileType > 0) {
                        drawTile(ctx, x, y, tileType);
                    }
                }
            }
        }

        // Fonction de rendu d'une tuile
        function drawTile(ctx, x, y, tileType) {
            const { tileSize } = config;
            
            // Couleurs selon le type de tuile
            const colors = {
                1: '#32CD32',  // Herbe
                2: '#8B4513',  // Terre
                3: '#696969',  // Pierre
                4: '#8B4513',  // Bois
                5: '#228B22',  // Feuilles
                6: '#2F2F2F',  // Charbon
                7: '#CD853F',  // Fer
                8: '#000000',  // Bedrock
                9: '#4169E1',  // Eau
                10: '#9370DB', // Cristal
                // Nouvelles tuiles RPG
                71: '#FFD700', // Pierre divine
                72: '#F0F8FF', // Terre b√©nie
                73: '#E6E6FA', // Cristal c√©leste
                101: '#8B0000', // Pierre infernale
                111: '#2F2F2F', // Pierre du vide
            };
            
            ctx.fillStyle = colors[tileType] || '#696969';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }

        // Fonction de rendu des entit√©s
        function drawEntities(ctx) {
            // Dessiner les PNJ
            if (game.pnjs) {
                game.pnjs.forEach(pnj => {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pnj.x - 8, pnj.y - 8, 16, 16);
                });
            }
            
            // Dessiner les ennemis
            if (game.enemies) {
                game.enemies.forEach(enemy => {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(enemy.x - 8, enemy.y - 8, 16, 16);
                });
            }
            
            // Dessiner les animaux
            if (game.animals) {
                game.animals.forEach(animal => {
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(animal.x - 6, animal.y - 6, 12, 12);
                });
            }
        }

        // Fonction de rendu du joueur
        function drawPlayer(ctx) {
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(game.player.x, game.player.y, game.player.w, game.player.h);
            
            // Indicateur de joueur
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px VT323';
            ctx.textAlign = 'center';
            ctx.fillText('VOUS', game.player.x + game.player.w/2, game.player.y - 5);
        }

        // Gestionnaire d'√©v√©nements clavier
        function setupKeyboardHandlers() {
            const keys = {};
            
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                // Raccourcis de l'interface RPG
                if (game && game.rpgInterface) {
                    switch (e.key.toLowerCase()) {
                        case 'i':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('inventoryWindow');
                            break;
                        case 'c':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('characterWindow');
                            break;
                        case 'q':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('questWindow');
                            break;
                        case 'm':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('mapWindow');
                            break;
                        case 'o':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('craftingWindow');
                            break;
                        case 'j':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('journalWindow');
                            break;
                        case 'escape':
                            e.preventDefault();
                            game.rpgInterface.toggleWindow('settingsWindow');
                            break;
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            return keys;
        }

        // Fonction principale de d√©marrage
        async function startGame() {
            console.log("üöÄ D√©marrage du jeu RPG...");
            
            try {
                // Initialiser le jeu
                await initializeGame();
                
                // Configurer les gestionnaires d'√©v√©nements
                const keys = setupKeyboardHandlers();
                
                // Redimensionnement automatique
                window.addEventListener('resize', resizeCanvas);
                
                // D√©marrer le moteur de jeu
                await engine.start(gameLogic);
                
                console.log("‚úÖ Jeu RPG d√©marr√© avec succ√®s !");
                
                // Notification de bienvenue
                if (game && game.rpgInterface) {
                    setTimeout(() => {
                        game.rpgInterface.showNotification(
                            'Bienvenue dans Super Pixel Adventure 2 - RPG Edition !',
                            'success',
                            5000
                        );
                    }, 1000);
                }
                
            } catch (error) {
                console.error("‚ùå Erreur lors du d√©marrage du jeu:", error);
                
                // Afficher une erreur plus d√©taill√©e
                const errorMessage = `Erreur lors du d√©marrage du jeu:\n${error.message}\n\nVeuillez v√©rifier la console pour plus de d√©tails.`;
                alert(errorMessage);
            }
        }

        // FIXED: Improved error handling for DOM loading
        document.addEventListener('DOMContentLoaded', () => {
            console.log("üìÑ DOM charg√©, d√©marrage du jeu...");
            
            // Ajouter un d√©lai pour s'assurer que tout est pr√™t
            setTimeout(() => {
                startGame().catch(error => {
                    console.error("Erreur fatale:", error);
                    alert("Impossible de d√©marrer le jeu. Veuillez recharger la page.");
                });
            }, 100);
        });

        // Rendre les fonctions accessibles globalement
        window.game = game;
        window.initializeGame = initializeGame;
        window.startGame = startGame;
        
        // FIXED: Add global error handler
        window.addEventListener('error', (event) => {
            console.error('Erreur globale:', event.error);
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promesse rejet√©e:', event.reason);
        });
        
    </script>
</body>
</html>